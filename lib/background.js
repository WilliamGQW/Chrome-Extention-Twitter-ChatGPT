/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	// The require scope
/******/ 	var __webpack_require__ = {};
/******/
/************************************************************************/
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function () {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
                /******/
            } catch (e) {
/******/ 				if (typeof window === 'object') return window;
                /******/
            }
            /******/
        })();
        /******/
    })();
    /******/
    /************************************************************************/
    var __webpack_exports__ = {};

    ;// CONCATENATED MODULE: ./node_modules/@microsoft/fetch-event-source/lib/esm/parse.js
    async function getBytes(stream, onChunk) {
        const reader = stream.getReader();
        let result;
        while (!(result = await reader.read()).done) {
            onChunk(result.value);
        }
    }
    function getLines(onLine) {
        let buffer;
        let position;
        let fieldLength;
        let discardTrailingNewline = false;
        return function onChunk(arr) {
            if (buffer === undefined) {
                buffer = arr;
                position = 0;
                fieldLength = -1;
            }
            else {
                buffer = concat(buffer, arr);
            }
            const bufLength = buffer.length;
            let lineStart = 0;
            while (position < bufLength) {
                if (discardTrailingNewline) {
                    if (buffer[position] === 10) {
                        lineStart = ++position;
                    }
                    discardTrailingNewline = false;
                }
                let lineEnd = -1;
                for (; position < bufLength && lineEnd === -1; ++position) {
                    switch (buffer[position]) {
                        case 58:
                            if (fieldLength === -1) {
                                fieldLength = position - lineStart;
                            }
                            break;
                        case 13:
                            discardTrailingNewline = true;
                        case 10:
                            lineEnd = position;
                            break;
                    }
                }
                if (lineEnd === -1) {
                    break;
                }
                onLine(buffer.subarray(lineStart, lineEnd), fieldLength);
                lineStart = position;
                fieldLength = -1;
            }
            if (lineStart === bufLength) {
                buffer = undefined;
            }
            else if (lineStart !== 0) {
                buffer = buffer.subarray(lineStart);
                position -= lineStart;
            }
        };
    }
    function getMessages(onId, onRetry, onMessage) {
        let message = newMessage();
        const decoder = new TextDecoder();
        return function onLine(line, fieldLength) {
            if (line.length === 0) {
                onMessage === null || onMessage === void 0 ? void 0 : onMessage(message);
                message = newMessage();
            }
            else if (fieldLength > 0) {
                const field = decoder.decode(line.subarray(0, fieldLength));
                const valueOffset = fieldLength + (line[fieldLength + 1] === 32 ? 2 : 1);
                const value = decoder.decode(line.subarray(valueOffset));
                switch (field) {
                    case 'data':
                        message.data = message.data
                            ? message.data + '\n' + value
                            : value;
                        break;
                    case 'event':
                        message.event = value;
                        break;
                    case 'id':
                        onId(message.id = value);
                        break;
                    case 'retry':
                        const retry = parseInt(value, 10);
                        if (!isNaN(retry)) {
                            onRetry(message.retry = retry);
                        }
                        break;
                }
            }
        };
    }
    function concat(a, b) {
        const res = new Uint8Array(a.length + b.length);
        res.set(a);
        res.set(b, a.length);
        return res;
    }
    function newMessage() {
        return {
            data: '',
            event: '',
            id: '',
            retry: undefined,
        };
    }
    //# sourceMappingURL=parse.js.map
    ;// CONCATENATED MODULE: ./node_modules/@microsoft/fetch-event-source/lib/esm/fetch.js
    var __rest = (undefined && undefined.__rest) || function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    };

    const EventStreamContentType = 'text/event-stream';
    const DefaultRetryInterval = 1000;
    const LastEventId = 'last-event-id';
    function fetchEventSource(input, _a) {
        var { signal: inputSignal, headers: inputHeaders, onopen: inputOnOpen, onmessage, onclose, onerror, openWhenHidden, fetch: inputFetch } = _a, rest = __rest(_a, ["signal", "headers", "onopen", "onmessage", "onclose", "onerror", "openWhenHidden", "fetch"]);
        return new Promise((resolve, reject) => {
            const headers = Object.assign({}, inputHeaders);
            if (!headers.accept) {
                headers.accept = EventStreamContentType;
            }
            let curRequestController;
            function onVisibilityChange() {
                curRequestController.abort();
                if (!document.hidden) {
                    create();
                }
            }
            if (!openWhenHidden) {
                document.addEventListener('visibilitychange', onVisibilityChange);
            }
            let retryInterval = DefaultRetryInterval;
            let retryTimer = 0;
            function dispose() {
                document.removeEventListener('visibilitychange', onVisibilityChange);
                window.clearTimeout(retryTimer);
                curRequestController.abort();
            }
            inputSignal === null || inputSignal === void 0 ? void 0 : inputSignal.addEventListener('abort', () => {
                dispose();
                resolve();
            });
            const fetch = inputFetch !== null && inputFetch !== void 0 ? inputFetch : window.fetch;
            const onopen = inputOnOpen !== null && inputOnOpen !== void 0 ? inputOnOpen : defaultOnOpen;
            async function create() {
                var _a;
                curRequestController = new AbortController();
                try {
                    const response = await fetch(input, Object.assign(Object.assign({}, rest), { headers, signal: curRequestController.signal }));
                    await onopen(response);
                    await getBytes(response.body, getLines(getMessages(id => {
                        if (id) {
                            headers[LastEventId] = id;
                        }
                        else {
                            delete headers[LastEventId];
                        }
                    }, retry => {
                        retryInterval = retry;
                    }, onmessage)));
                    onclose === null || onclose === void 0 ? void 0 : onclose();
                    dispose();
                    resolve();
                }
                catch (err) {
                    if (!curRequestController.signal.aborted) {
                        try {
                            const interval = (_a = onerror === null || onerror === void 0 ? void 0 : onerror(err)) !== null && _a !== void 0 ? _a : retryInterval;
                            window.clearTimeout(retryTimer);
                            retryTimer = window.setTimeout(create, interval);
                        }
                        catch (innerErr) {
                            dispose();
                            reject(innerErr);
                        }
                    }
                }
            }
            create();
        });
    }
    function defaultOnOpen(response) {
        const contentType = response.headers.get('content-type');
        if (!(contentType === null || contentType === void 0 ? void 0 : contentType.startsWith(EventStreamContentType))) {
            throw new Error(`Expected content-type to be ${EventStreamContentType}, Actual: ${contentType}`);
        }
    }
    //# sourceMappingURL=fetch.js.map
    ;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/native.js
    const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);
/* harmony default export */ const esm_browser_native = ({
        randomUUID
    });
    ;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/rng.js
    // Unique ID creation requires a high quality random # generator. In the browser we therefore
    // require the crypto API and do not support built-in fallback to lower quality random number
    // generators (like Math.random()).
    let getRandomValues;
    const rnds8 = new Uint8Array(16);
    function rng() {
        // lazy load so that environments that need to polyfill have a chance to do so
        if (!getRandomValues) {
            // getRandomValues needs to be invoked in a context where "this" is a Crypto implementation.
            getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);

            if (!getRandomValues) {
                throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');
            }
        }

        return getRandomValues(rnds8);
    }
    ;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/stringify.js

    /**
     * Convert array of 16 byte values to UUID string format of the form:
     * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
     */

    const byteToHex = [];

    for (let i = 0; i < 256; ++i) {
        byteToHex.push((i + 0x100).toString(16).slice(1));
    }

    function unsafeStringify(arr, offset = 0) {
        // Note: Be careful editing this code!  It's been tuned for performance
        // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
        return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
    }

    function stringify(arr, offset = 0) {
        const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one
        // of the following:
        // - One or more input array values don't map to a hex octet (leading to
        // "undefined" in the uuid)
        // - Invalid input values for the RFC `version` or `variant` fields

        if (!validate(uuid)) {
            throw TypeError('Stringified UUID is invalid');
        }

        return uuid;
    }

/* harmony default export */ const esm_browser_stringify = ((/* unused pure expression or super */ null && (stringify)));
    ;// CONCATENATED MODULE: ./node_modules/uuid/dist/esm-browser/v4.js

    function v4(options, buf, offset) {
        if (esm_browser_native.randomUUID && !buf && !options) {
            return esm_browser_native.randomUUID();
        }

        options = options || {};
        const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`

        rnds[6] = rnds[6] & 0x0f | 0x40;
        rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided

        if (buf) {
            offset = offset || 0;

            for (let i = 0; i < 16; ++i) {
                buf[offset + i] = rnds[i];
            }

            return buf;
        }

        return unsafeStringify(rnds);
    }

/* harmony default export */ const esm_browser_v4 = (v4);
    ;// CONCATENATED MODULE: ./src/utils/wait.ts
    const wait = (timeout) => {
        return new Promise((res) => setTimeout(() => res(null), timeout));
    };

    ;// CONCATENATED MODULE: ./src/background/chat_gpt_client/chat_gpt_client.ts

    // polyfill for @microsoft/fetch-event-source
    __webpack_require__.g.window ||= {};
    __webpack_require__.g.window.fetch = fetch;
    __webpack_require__.g.window.setTimeout = ((cb, interval) => {
        const timeoutId = setTimeout(cb, interval);
        return timeoutId;
    });
    __webpack_require__.g.window.clearTimeout = (timeoutId) => {
        return clearTimeout(timeoutId);
    };
    __webpack_require__.g.document ||= {};
    __webpack_require__.g.document.addEventListener = (_, __) => null;
    __webpack_require__.g.document.removeEventListener = (_, __) => null;
    const baseUrl = "https://chat.openai.com/backend-api";
    class ChatGPTClient {
        gptToken;
        waitForTokenCallback;
        constructor() {
            chrome.storage.local.get("gpt_token").then((result) => this.gptToken = result.gpt_token);
        }
        async generateTweet(prompt, onPartialResults, onError, repeat = true) {
            const gptToken = await this.getOpenAIToken();
            if (!gptToken) {
                return undefined;
            }
            const payload = {
                "action": "next",
                "messages": [
                    {
                        "id": esm_browser_v4(),
                        "role": "user",
                        "content": {
                            "content_type": "text",
                            "parts": [prompt]
                        }
                    }
                ],
                "parent_message_id": esm_browser_v4(),
                "model": "text-davinci-002-render"
            };
            const self = this;
            let tweet = undefined;
            let isValidToken = true;
            try {
                const ctrl = new AbortController();
                await fetchEventSource(`${baseUrl}/conversation`, {
                    method: 'POST',
                    openWhenHidden: true,
                    fetch: fetch,
                    headers: {
                        'Content-Type': 'application/json',
                        'authorization': `Bearer ${this.gptToken}`,
                    },
                    body: JSON.stringify(payload),
                    onopen: async (response) => {
                        if (response.status === 401 || response.status === 403) {
                            // token expired or invalid
                            isValidToken = false;
                        }
                        if (response.status >= 500) {
                            onError();
                        }
                    },
                    onerror: (error) => {
                        throw new Error(error); //it wouldn't stop otherwise
                    },
                    onclose: () => {
                        onError();
                    },
                    onmessage(ev) {
                        if (ev.data === '[DONE]') {
                            ctrl.abort();
                        }
                        else {
                            tweet = self.getTextFromResponse(ev.data);
                            onPartialResults(tweet);
                        }
                    },
                    signal: ctrl.signal,
                });
            }
            catch (e) {
                onError();
                console.log(e);
            }
            if (!isValidToken) {
                this.gptToken = undefined;
            }
            // we didn't get a tweet because token wasn't valid
            if (!tweet && !isValidToken && repeat) {
                const newToken = await this.getOpenAIToken();
                if (newToken) {
                    return this.generateTweet(prompt, onPartialResults, onError, false); // we repeat only once
                }
            }
            return tweet;
        }
        getTextFromResponse(response) {
            const message = JSON.parse(response);
            let tweet = message?.message?.content?.parts[0] || '';
            tweet = tweet.trim().replace(/"([^"]*)[#"]?/g, '$1');
            return tweet;
        }
        updateToken(token) {
            this.gptToken = token;
            chrome.storage.local.set({ "gpt_token": token });
            if (this.waitForTokenCallback) {
                this.waitForTokenCallback(token);
                this.waitForTokenCallback = undefined;
            }
        }
        async getOpenAIToken() {
            if (!this.gptToken) {
                var chatUrl = "https://chat.openai.com/";
                chrome.windows.create({ url: chatUrl });
                return Promise.race([
                    new Promise((resolve) => {
                        this.waitForTokenCallback = resolve;
                    }),
                    wait(10000).then(() => {
                        this.waitForTokenCallback = undefined;
                        return undefined;
                    })
                ]);
            }
            return this.gptToken;
        }
    }

    ;// CONCATENATED MODULE: ./src/background/background.ts

    const gptChat = new ChatGPTClient();
    chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
        if (!message.type) {
            return;
        }
        switch (message.type) {
            case 'generate_tweet':
                const requestId = message.requestId;
                const onPartialResults = async (tweet) => {
                    const { isRealtime } = await chrome.storage.local.get('isRealtime');
                    if (isRealtime) {
                        chrome.tabs.sendMessage(sender.tab.id, { type: 'partial_tweet', tweet, requestId });
                    }
                };
                const onError = (repeat) => sendResponse(undefined);
                gptChat.generateTweet(message.prompt, onPartialResults, onError).then(async (text) => {
                    if (!text) {
                        return sendResponse(undefined);
                    }
                    let finalText = text;
                    sendResponse(finalText);
                }, onError);
                break;
            case 'new_openai_token':
                const token = message.token;
                gptChat.updateToken(token);
                chrome.tabs.sendMessage(sender.tab.id, { type: 'close_openai_window' });
                break;
        }
        return true;
    });

    /******/
})()
    ;